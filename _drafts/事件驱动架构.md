# 事件驱动架构



先来说说**EventBus**,相信基本上每个人都用过它,

因为被设计的简单易用,看下文档我们就可以很快上手.

虽然感觉之前一直漏掉了一些东西:





之前我对事件驱动,事件总线这些东西也没有一个清晰的概念.

看到关于**EventBus**的使用基本都是分析源码,然后是*hello world*类型的**demo**

- 比如在`Fragment`和`Activity`之前传递事件(不过是减少一点样板代码:as Callback or Lisenter)
- 比如在一些难以控制UI的地方发送事件,然后在View层更新(往往是**Controller**,**Presenter** ,**Adapter**里面)



然后关于解耦关于模块化的话题,老生常谈了

主要还是因为代码是写给人看的...自己都不想碰了就tm尴尬了

像我每次面对一个新需求,都在想之前自己写的是什么垃圾代码?



为什么我要把这段代码在不同的地方写两遍?

为什么10W行的*code*,会有3W行的*refactoring*和*rewritting*?

>  当然还有6W行是*.xml*,😄



之前在看**[Android-CleanArchitecture](https://github.com/android10/Android-CleanArchitecture)**的时候就发现里面有**[ThreadPoolExecutor](https://github.com/android10/Android-CleanArchitecture/blob/master/data/src/main/java/com/fernandocejas/android10/sample/data/executor/JobExecutor.java)**

当时一脸懵逼,再看了一遍**EventBus**的文档,然后简单了解了一下事件驱动编程

> 发现之前我可能上了一个假的**EventBus**



---



事件驱动编程范式其实很常见...随手画了一个思维导图

- 外面的是视图层

  用户的不同操作(比如*上上下下左左右右ABAB*)可以代表同一个事件:背后的业务逻辑,发送出去然后等待回调作出响应.

- 中间的是事件处理器.

许多情况下，事件处理器可以自己处理事件，因此也可能发送一个事件(回调)

它可能是一个main loop,不停循环地检测和处理事件(感觉这样肯定是不好的)

也可能会是一个Executor,注入不同的Thread,处理和发送事件 



不知道这样说对不对,不同于软件架构(为了解耦和模块化),事件驱动程序设计着重于弹性和异步化,并且尽可能的***modeless***(不用强制等待回调然后作出响应)



不过既然用**EventBus**,就不用关心那么多了...

写一个类同时作为`Observer`和`Subscriber`,在那里订阅和发送事件就好了



下面要讲一点**EventBus**了



不行不行,打字已经说不清楚了 我要上代码了

>  一个发送评论的功能

```java
public class CommentBus implements CommentContact.Bus {
    @NotNull
    private final RemoteDataSource remoteDataSource;
    private final CompositeSubscription mCompositeSubscription;

    @Inject
    public CommentBus(@NotNull RemoteDataSource remoteDataSource) {
        this.remoteDataSource = remoteDataSource;
        mCompositeSubscription = new CompositeSubscription();
    }

    @Inject
    @Override
    public void register() {
        EventBus.getDefault().register(this);
    }

    @Override
    public void unregister() {
        if (EventBus.getDefault().isRegistered(this))
            EventBus.getDefault().unregister(this);
        if (!mCompositeSubscription.isUnsubscribed())
            mCompositeSubscription.unsubscribe();
    }


    @Subscribe(threadMode = ThreadMode.MAIN)
    public void onPostComment(final CommentPostEvent event) {
        postComment(event.getExecutionScope());
    }

    @Override
    public void postComment(Object scope) {
        mCompositeSubscription.add(remoteDataSource.postComment()
                .subscribe(new Observer<Comment>() {
                  	//...skip
                    @Override
                    public void onError(Throwable e) {
                        CommentPostCallback callback = new CommentPostCallback(e);
                        callback.setExecutionScope(scope);
                        EventBus.getDefault().post(callback);
                    }

                    @Override
                    public void onNext(Comment comment) {
                        CommentPostCallback callback = new CommentPostCallback(comment);
                        callback.setExecutionScope(scope);
                        EventBus.getDefault().post(callback);
                    }
                }));
    }
}
```

`CommentBus`,在需要的时候注入,它的`Scope`一般是和`Activity`/`Fragment`相同,因为我们并不是任何时候都需要监听此类事件.

用了**Dagger2**之后 感觉很好的就是强调了每个实例的`Scope`,而我们也是需要一个个`Context`才能维持各种组件的正常工作,殊途同归

比如你在**Event**中也加入它的`Scope`:

```java
public class CommentPostEvent implements HasExecutionScope {
  	private Object executionScope;
  
    @Override
    public Object getExecutionScope() {
        return executionScope;
    }

    @Override
    public void setExecutionScope(Object executionScope) {
        this.executionScope = executionScope;
    }
}
```

### HasExecutionScope

炒鸡有用的一个接口,因为订阅可以变得很混乱和难以处理

比如页面ABCD都订阅了事件E,页面ABCD的实例都存在于栈中(当然这种情况比较少,App的页面深度有限)然后你只想页面A响应它自己发出事件的回调.

之前不知道这个接口的时候,我会自己傻乎乎地给Event加一个TAG...

现在只要在发送事件的时候设置一个Scope

```java
CommentPostEvent event = new CommentPostEvent();
event.setExecutionScope(this);
EventBus.getDefault().post(event);
```

然后在Subscriber里面判断是否是同一个Scope

```java
@Subscribe(threadMode = ThreadMode.MAIN)
public void onPostCommentCallback(CommentPostCallback callback) {
    if (PostCommentActivity.class.equals(callback.getExecutionScope())) {
       // do something cool
    }
}
```
### Priorities

当然订阅还可以有优先级

```java
@Subscribe(priority = 1);
public void onEvent(CommentPostCallback callback) {
    ...
}
```

大多数情况下我们都不会用到Event的优先级或者事件的取消发送,但是有些时候它还是能派上用场.

比如一个事件在前台或者后台的时候需要有不同的UI处理逻辑

比如在高优先级的Subscriber处理事件的时候取消向下发送,通过调用`cancelEventDelivery(Object event)`

> 注意: 在**同一个**发送事件的线程下,设置优先级才会生效(默认为0)



### FAQs

>  *但还是有好多个为什么.有**dalao**带我上车吗...滴,学生卡* 🚌

**Q1**:

因为**EventBus**只是一个组件之间解耦的工具,我们在开发中还是要选择合适的软件架构(比如**MVP**).

那么问题来了,在**View**,**Usecase**,**Data**三个层次,应该用一个事件总线呢还是多个?

如果是一个,复杂度明显会增加很多;如果是多个,可能我们在不同的层级之间要重复发送很多相同的事件.

**Q1.1**:

然后还要面临另外一个问题,当项目里面都是各种**Event**的时候,怎么更好地管理混乱的代码?

>  *If any one give me a working example much appreciated*,*thanks in advance*

**Q2**:

既然有了事件驱动,那么是不是就不用**Presenter**了.因为Presenter有时候还是会难以复用,避免不了一堆样板代码或者空接口.

当然你可以把Presenter的功能再细分,在一个页面注入多个Presenter.但是感觉没有用Post Event的方式来的酷炫,而且可以更容易协作开发上层的代码.



> 你在onEvent()做某种初始化的话
>
> 当acitivity重建的时候 不能retain state

